#!/usr/bin/env python3
"""
Generate dummy model weights for Spectral-Gate TinyML inference.

This script creates a model_weights.h file containing quantized int8 weights
for a simple single-layer neural network classifier. In production, these
weights would be trained using TensorFlow Lite for Microcontrollers or
similar framework.

Usage:
    python generate_physics.py [--output PATH] [--input-size N] [--output-size N]
"""

import argparse
import random
from pathlib import Path
from datetime import datetime


def generate_random_weights(input_size: int, output_size: int, seed: int = 42) -> tuple:
    """Generate random quantized weights and biases."""
    random.seed(seed)
    
    # Generate weights in range [-64, 63] (int8 subset)
    weights = [[random.randint(-64, 63) for _ in range(input_size)] for _ in range(output_size)]
    
    # Generate biases
    biases = [random.randint(-32, 31) for _ in range(output_size)]
    
    return weights, biases


def format_weight_array(weights: list, name: str, per_line: int = 16) -> str:
    """Format weight array as C++ array initializer."""
    # Flatten if nested list
    if weights and isinstance(weights[0], list):
        flat = [v for row in weights for v in row]
    else:
        flat = weights
    
    lines = []
    for i in range(0, len(flat), per_line):
        chunk = flat[i:i + per_line]
        line = ", ".join(f"{v:4d}" for v in chunk)
        lines.append(f"    {line}")
    
    return f"constexpr int8_t {name}[] = {{\n" + ",\n".join(lines) + "\n};"


def generate_header(input_size: int, output_size: int, weights: list, biases: list) -> str:
    """Generate complete header file content."""
    
    # Q15.16 fixed-point scale factor (1.0 = 65536)
    scale_factor = 65536  # FIXED_ONE
    
    header = f"""#ifndef MODEL_WEIGHTS_H
#define MODEL_WEIGHTS_H

/**
 * @file model_weights.h
 * @brief Quantized model weights for Spectral-Gate TinyML inference
 * 
 * Auto-generated by generate_physics.py on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
 * 
 * Model Architecture:
 *   - Input:  {input_size} spectral features (normalized fixed-point)
 *   - Output: {output_size} classes (0=normal, 1=anomaly, 2=uncertain)
 *   - Type:   Single-layer perceptron with quantized int8 weights
 * 
 * Quantization:
 *   - Weights: int8 [-128, 127], effective range ~[-1.0, 1.0]
 *   - Biases:  int8 [-128, 127]
 *   - Scale:   Q15.16 fixed-point
 */

#include <cstdint>

// Model dimensions
constexpr size_t MODEL_INPUT_SIZE = {input_size};
constexpr size_t MODEL_OUTPUT_SIZE = {output_size};

// Quantization scale factor (Q15.16 format, represents 1.0)
constexpr int32_t MODEL_SCALE_FACTOR = {scale_factor};

// Quantized weights: [{output_size}][{input_size}] stored row-major
{format_weight_array(weights, "MODEL_WEIGHTS")}

// Quantized biases: [{output_size}]
{format_weight_array(biases, "MODEL_BIASES", per_line=output_size)}

#endif // MODEL_WEIGHTS_H
"""
    return header


def main():
    parser = argparse.ArgumentParser(
        description="Generate dummy TinyML model weights for Spectral-Gate"
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        default=Path(__file__).parent / "model_weights.h",
        help="Output header file path (default: data/model_weights.h)"
    )
    parser.add_argument(
        "--input-size", "-i",
        type=int,
        default=64,
        help="Number of input features/spectral bins (default: 64)"
    )
    parser.add_argument(
        "--output-size", "-c",
        type=int,
        default=3,
        help="Number of output classes (default: 3)"
    )
    parser.add_argument(
        "--seed", "-s",
        type=int,
        default=42,
        help="Random seed for reproducibility (default: 42)"
    )
    
    args = parser.parse_args()
    
    print(f"Generating model weights:")
    print(f"  Input size:  {args.input_size}")
    print(f"  Output size: {args.output_size}")
    print(f"  Seed:        {args.seed}")
    
    # Generate weights
    weights, biases = generate_random_weights(
        args.input_size, 
        args.output_size, 
        args.seed
    )
    
    # Generate header content
    header_content = generate_header(
        args.input_size,
        args.output_size,
        weights,
        biases
    )
    
    # Write output file
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(header_content)
    
    print(f"  Output:      {args.output}")
    weight_count = len(weights) * len(weights[0]) if weights else 0
    print(f"  Weights:     ({len(weights)}, {len(weights[0]) if weights else 0}) ({weight_count} bytes)")
    print(f"  Biases:      ({len(biases)},) ({len(biases)} bytes)")
    print("Done!")


if __name__ == "__main__":
    main()
